{% set imports = properties | map(attribute="range") | unique | reject("equalto", "str") | reject("equalto", None) | list %}
from pydantic import BaseModel, Field, validator, root_validator
from typing import Optional, List, Union

{% for parent_class in parent_classes if parent_class != "BaseModel" %}
{% if parent_class in custom_models %}
from ..custom.{{ parent_class }}Module import {{ parent_class }}
{% else %}
from .{{ parent_class }}Module import {{ parent_class }}
{% endif %}
{% endfor %}

{% for imp in imports %}
{% if imp in custom_models %}
from ..custom.{{ imp }}Module import {{ imp }}
{% else %}
from .{{ imp }}Module import {{ imp }}
{% endif %}
{% endfor %}

{% if additional_imports %}
# Custom imports
{% for imp in additional_imports %}
{{ imp }}
{% endfor %}
{% endif %}


class {{ class_name }}({{ ', '.join(parent_classes) }}):
    {% if properties %}
    {% for prop in properties %}
    {{ prop.name }}: Optional[{{ prop.range }}] = Field(
        {% if prop.default %}
            {{ prop.default }},
        {% else %}
            None,
        {% endif %}
        alias="{{ prop.alias if 'alias' in prop else prop.name }}"
    )
    {% endfor %}


    {% for prop in properties if prop.range not in ["str", "Union[int, float]", "int", "float"] %}
    @validator("{{ prop.name }}", pre=True, always=True)
    def validate_{{ prop.name }}(cls, value):
        if value is not None and not isinstance(value, {{ prop.range }}):
            raise ValueError(f"Field '{{ prop.name }}' must be an instance of '{{ prop.range }}' or its subclass.")
        return value
    {% endfor %}
    {% endif %}

    {% if methods %}
    {% for method in methods %}
    {{ method | safe }}
    {% endfor %}
    {% endif %}

    {% if not properties and not methods %}
    pass
    {% endif %}
